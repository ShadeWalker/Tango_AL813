/*
* Copyright (C) 2014 MediaTek Inc.
* Modification based on code covered by the mentioned copyright
* and/or permission notice(s).
*/
/*
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.telephony;

/**
 * Contains disconnect call causes generated by the framework and the RIL.
 * @hide
 */
public class DisconnectCause {

    /** The disconnect cause is not valid (Not received a disconnect cause) */
    public static final int NOT_VALID                      = -1;
    /** Has not yet disconnected */
    public static final int NOT_DISCONNECTED               = 0;
    /** An incoming call that was missed and never answered */
    public static final int INCOMING_MISSED                = 1;
    /** Normal; Remote hangup*/
    public static final int NORMAL                         = 2;
    /** Normal; Local hangup */
    public static final int LOCAL                          = 3;
    /** Outgoing call to busy line */
    public static final int BUSY                           = 4;
    /** Outgoing call to congested network */
    public static final int CONGESTION                     = 5;
    /** Not presently used */
    public static final int MMI                            = 6;
    /** Invalid dial string */
    public static final int INVALID_NUMBER                 = 7;
    /** Cannot reach the peer */
    public static final int NUMBER_UNREACHABLE             = 8;
    /** Cannot reach the server */
    public static final int SERVER_UNREACHABLE             = 9;
    /** Invalid credentials */
    public static final int INVALID_CREDENTIALS            = 10;
    /** Calling from out of network is not allowed */
    public static final int OUT_OF_NETWORK                 = 11;
    /** Server error */
    public static final int SERVER_ERROR                   = 12;
    /** Client timed out */
    public static final int TIMED_OUT                      = 13;
    /** Client went out of network range */
    public static final int LOST_SIGNAL                    = 14;
    /** GSM or CDMA ACM limit exceeded */
    public static final int LIMIT_EXCEEDED                 = 15;
    /** An incoming call that was rejected */
    public static final int INCOMING_REJECTED              = 16;
    /** Radio is turned off explicitly */
    public static final int POWER_OFF                      = 17;
    /** Out of service */
    public static final int OUT_OF_SERVICE                 = 18;
    /** No ICC, ICC locked, or other ICC error */
    public static final int ICC_ERROR                      = 19;
    /** Call was blocked by call barring */
    public static final int CALL_BARRED                    = 20;
    /** Call was blocked by fixed dial number */
    public static final int FDN_BLOCKED                    = 21;
    /** Call was blocked by restricted all voice access */
    public static final int CS_RESTRICTED                  = 22;
    /** Call was blocked by restricted normal voice access */
    public static final int CS_RESTRICTED_NORMAL           = 23;
    /** Call was blocked by restricted emergency voice access */
    public static final int CS_RESTRICTED_EMERGENCY        = 24;
    /** Unassigned number */
    public static final int UNOBTAINABLE_NUMBER            = 25;
    /** MS is locked until next power cycle */
    public static final int CDMA_LOCKED_UNTIL_POWER_CYCLE  = 26;
    /** Drop call*/
    public static final int CDMA_DROP                      = 27;
    /** INTERCEPT order received, MS state idle entered */
    public static final int CDMA_INTERCEPT                 = 28;
    /** MS has been redirected, call is cancelled */
    public static final int CDMA_REORDER                   = 29;
    /** Service option rejection */
    public static final int CDMA_SO_REJECT                 = 30;
    /** Requested service is rejected, retry delay is set */
    public static final int CDMA_RETRY_ORDER               = 31;
    /** Unable to obtain access to the CDMA system */
    public static final int CDMA_ACCESS_FAILURE            = 32;
    /** Not a preempted call */
    public static final int CDMA_PREEMPTED                 = 33;
    /** Not an emergency call */
    public static final int CDMA_NOT_EMERGENCY             = 34;
    /** Access Blocked by CDMA network */
    public static final int CDMA_ACCESS_BLOCKED            = 35;
    /** Unknown error or not specified */
    public static final int ERROR_UNSPECIFIED              = 36;
    /**
     * Only emergency numbers are allowed, but we tried to dial
     * a non-emergency number.
     */
    // TODO: This should be the same as NOT_EMERGENCY
    public static final int EMERGENCY_ONLY                 = 37;
    /**
     * The supplied CALL Intent didn't contain a valid phone number.
     */
    public static final int NO_PHONE_NUMBER_SUPPLIED       = 38;
    /**
     * Our initial phone number was actually an MMI sequence.
     */
    public static final int DIALED_MMI                     = 39;
    /**
     * We tried to call a voicemail: URI but the device has no
     * voicemail number configured.
     */
    public static final int VOICEMAIL_NUMBER_MISSING       = 40;
    /**
     * This status indicates that InCallScreen should display the
     * CDMA-specific "call lost" dialog.  (If an outgoing call fails,
     * and the CDMA "auto-retry" feature is enabled, *and* the retried
     * call fails too, we display this specific dialog.)
     *
     * TODO: this is currently unused, since the "call lost" dialog
     * needs to be triggered by a *disconnect* event, rather than when
     * the InCallScreen first comes to the foreground.  For now we use
     * the needToShowCallLostDialog field for this (see below.)
     */
    public static final int CDMA_CALL_LOST                 = 41;
    /**
     * This status indicates that the call was placed successfully,
     * but additionally, the InCallScreen needs to display the
     * "Exiting ECM" dialog.
     *
     * (Details: "Emergency callback mode" is a CDMA-specific concept
     * where the phone disallows data connections over the cell
     * network for some period of time after you make an emergency
     * call.  If the phone is in ECM and you dial a non-emergency
     * number, that automatically *cancels* ECM, but we additionally
     * need to warn the user that ECM has been canceled (see bug
     * 4207607.))
     *
     * TODO: Rethink where the best place to put this is. It is not a notification
     * of a failure of the connection -- it is an additional message that accompanies
     * a successful connection giving the user important information about what happened.
     *
     * {@hide}
     */
    public static final int EXITED_ECM                     = 42;

    /**
     * The outgoing call failed with an unknown cause.
     */
    public static final int OUTGOING_FAILURE = 43;

    /**
     * The outgoing call was canceled by the {@link android.telecom.ConnectionService}.
     */
    public static final int OUTGOING_CANCELED = 44;

    /**
     * The call, which was an IMS call, disconnected because it merged with another call.
     */
    public static final int IMS_MERGED_SUCCESSFULLY = 45;

    /**
     * Stk Call Control modified DIAL request to USSD request.
     * {@hide}
     */
    public static final int DIAL_MODIFIED_TO_USSD          = 46;
    /**
     * Stk Call Control modified DIAL request to SS request.
     * {@hide}
     */
    public static final int DIAL_MODIFIED_TO_SS            = 47;
    /**
     * Stk Call Control modified DIAL request to DIAL with modified data.
     * {@hide}
     */
    public static final int DIAL_MODIFIED_TO_DIAL          = 48;

    //*********************************************************************************************
    // When adding a disconnect type:
    // 1) Please assign the new type the next id value below.
    // 2) Increment the next id value below to a new value.
    // 3) Update MAXIMUM_VALID_VALUE to the new disconnect type.
    // 4) Update toString() with the newly added disconnect type.
    // 5) Update android.telecom.DisconnectCauseUtil with any mappings to a telecom.DisconnectCause.
    //
    // NextId: 49
    //*********************************************************************************************

    /// M: CC008: Call Fail Cause based on CEER @{
    /// [ALPS00093395]
    /**
     * @hide
     */
    public static final int MTK_DISCONNECTED_CAUSE_BASE    = DIAL_MODIFIED_TO_DIAL;
    /** no route to destination
     * @hide
     */
    public static final int NO_ROUTE_TO_DESTINATION        = MTK_DISCONNECTED_CAUSE_BASE + 1;
    /** no user responding
     * @hide
     */
    public static final int NO_USER_RESPONDING             = MTK_DISCONNECTED_CAUSE_BASE + 2;
    /** user alerting, no answer
     * @hide
     */
    public static final int USER_ALERTING_NO_ANSWER        = MTK_DISCONNECTED_CAUSE_BASE + 3;
    /** call rejected
     * @hide
     */
    public static final int CALL_REJECTED                  = MTK_DISCONNECTED_CAUSE_BASE + 4;
    /** invalid number format
     * @hide
     */
    public static final int INVALID_NUMBER_FORMAT          = MTK_DISCONNECTED_CAUSE_BASE + 5;
    /** facility rejected
     * @hide
     */
    public static final int FACILITY_REJECTED              = MTK_DISCONNECTED_CAUSE_BASE + 6;
    /** normal, unspecified
     * @hide
     */
    public static final int NORMAL_UNSPECIFIED             = MTK_DISCONNECTED_CAUSE_BASE + 7;
    /** no circuit/channel available
     * @hide
     */
    public static final int NO_CIRCUIT_AVAIL               = MTK_DISCONNECTED_CAUSE_BASE + 8;
    /** switching equipment congestion
     * @hide
     */
    public static final int SWITCHING_CONGESTION           = MTK_DISCONNECTED_CAUSE_BASE + 9;
    /** resource unavailable, unspecified
     * @hide
     */
    public static final int RESOURCE_UNAVAILABLE           = MTK_DISCONNECTED_CAUSE_BASE + 10;
    /** bearer capability not authorized
     * @hide
     */
    public static final int BEARER_NOT_AUTHORIZED          = MTK_DISCONNECTED_CAUSE_BASE + 11;
    /** bearer capability not presently available
     * @hide
     */
    public static final int BEARER_NOT_AVAIL               = MTK_DISCONNECTED_CAUSE_BASE + 12;
    /** service or option not available, unspecified
     * @hide
     */
    public static final int SERVICE_NOT_AVAILABLE          = MTK_DISCONNECTED_CAUSE_BASE + 13;
    /** bearer service not implemented
     * @hide
     */
    public static final int BEARER_NOT_IMPLEMENT           = MTK_DISCONNECTED_CAUSE_BASE + 14;
    /** Requested facility not implemented
     * @hide
     */
    public static final int FACILITY_NOT_IMPLEMENT         = MTK_DISCONNECTED_CAUSE_BASE + 15;
    /** only restricted digital information bearer capability is available
     * @hide
     */
    public static final int RESTRICTED_BEARER_AVAILABLE    = MTK_DISCONNECTED_CAUSE_BASE + 16;
    /** service or option not implemented, unspecified
     * @hide
     */
    public static final int OPTION_NOT_AVAILABLE           = MTK_DISCONNECTED_CAUSE_BASE + 17;
    /** incompatible destination
     * @hide
     */
    public static final int INCOMPATIBLE_DESTINATION       = MTK_DISCONNECTED_CAUSE_BASE + 18;
    /** RR connection release
     * @hide
     */
    public static final int CHANNEL_UNACCEPTABLE           = MTK_DISCONNECTED_CAUSE_BASE + 19;
    /**
     * @hide
     */
    public static final int OPERATOR_DETERMINED_BARRING    = MTK_DISCONNECTED_CAUSE_BASE + 20;
    /**
     * @hide
     */
    public static final int PRE_EMPTION                    = MTK_DISCONNECTED_CAUSE_BASE + 21;
    /**
     * @hide
     */
    public static final int NON_SELECTED_USER_CLEARING     = MTK_DISCONNECTED_CAUSE_BASE + 22;
    /**
     * @hide
     */
    public static final int DESTINATION_OUT_OF_ORDER       = MTK_DISCONNECTED_CAUSE_BASE + 23;
    /**
     * @hide
     */
    public static final int ACCESS_INFORMATION_DISCARDED   = MTK_DISCONNECTED_CAUSE_BASE + 24;
    /**
     * @hide
     */
    public static final int REQUESTED_FACILITY_NOT_SUBSCRIBED = MTK_DISCONNECTED_CAUSE_BASE + 25;
    /**
     * @hide
     */
    public static final int INCOMING_CALL_BARRED_WITHIN_CUG   = MTK_DISCONNECTED_CAUSE_BASE + 26;
    /**
     * @hide
     */
    public static final int INVALID_TRANSACTION_ID_VALUE   = MTK_DISCONNECTED_CAUSE_BASE + 27;
    /**
     * @hide
     */
    public static final int USER_NOT_MEMBER_OF_CUG         = MTK_DISCONNECTED_CAUSE_BASE + 28;
    /**
     * @hide
     */
    public static final int INVALID_TRANSIT_NETWORK_SELECTION = MTK_DISCONNECTED_CAUSE_BASE + 29;
    /**
     * @hide
     */
    public static final int SEMANTICALLY_INCORRECT_MESSAGE = MTK_DISCONNECTED_CAUSE_BASE + 30;
    /**
     * @hide
     */
    public static final int INVALID_MANDATORY_INFORMATION  = MTK_DISCONNECTED_CAUSE_BASE + 31;
    /**
     * @hide
     */
    public static final int MESSAGE_TYPE_NON_EXISTENT      = MTK_DISCONNECTED_CAUSE_BASE + 32;
    /**
     * @hide
     */
    public static final int MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROT_STATE = MTK_DISCONNECTED_CAUSE_BASE + 33;
    /**
     * @hide
     */
    public static final int IE_NON_EXISTENT_OR_NOT_IMPLEMENTED = MTK_DISCONNECTED_CAUSE_BASE + 34;
    /**
     * @hide
     */
    public static final int CONDITIONAL_IE_ERROR           = MTK_DISCONNECTED_CAUSE_BASE + 35;
    /**
     * @hide
     */
    public static final int MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = MTK_DISCONNECTED_CAUSE_BASE + 36;
    /**
     * @hide
     */
    public static final int RECOVERY_ON_TIMER_EXPIRY       = MTK_DISCONNECTED_CAUSE_BASE + 37;
    /**
     * @hide
     */
    public static final int PROTOCOL_ERROR_UNSPECIFIED     = MTK_DISCONNECTED_CAUSE_BASE + 38;
    /**
     * @hide
     */
    public static final int INTERWORKING_UNSPECIFIED       = MTK_DISCONNECTED_CAUSE_BASE + 39;
    /**
     * @hide
     */
    public static final int CM_MM_RR_CONNECTION_RELEASE    = MTK_DISCONNECTED_CAUSE_BASE + 40;
    /// @}
    /// M: CC021: Error message due to CellConnMgr checking @{
    /**
     * @hide
     */
    public static final int OUTGOING_CANCELED_BY_SERVICE   = MTK_DISCONNECTED_CAUSE_BASE + 41;
    /// @}
    /// M: CC022: Error message due to VoLTE SS checking @{
    /**
     * Reject MMI for setting SS under VoLTE without data setting enabled, since XCAP is thru HTTP
     * It shares same error string as modifying SS setting under same scenario.
     * see {@link com.android.services.telephony.DisconnectCauseUtil#toTelecomDisconnectCauseLabel}
     * @hide
     */
    public static final int VOLTE_SS_DATA_OFF              = MTK_DISCONNECTED_CAUSE_BASE + 42;
    /// @}
    public static final int CHANNEL_NOT_AVAIL              = MTK_DISCONNECTED_CAUSE_BASE + 43;

    // / Added by guofeiyao 2015/12/12
    // For Telcel clear code
    public static final int NUMBER_CHANGED = MTK_DISCONNECTED_CAUSE_BASE + 44; //22
	public static final int STATUS_ENQUIRY = MTK_DISCONNECTED_CAUSE_BASE + 45; //30
	public static final int NETWORK_OUT_OF_ORDER = MTK_DISCONNECTED_CAUSE_BASE + 46; //38
	public static final int QOS_NOT_AVAIL = MTK_DISCONNECTED_CAUSE_BASE + 47; //49

    public static final int NORMAL_CLEARING = MTK_DISCONNECTED_CAUSE_BASE + 48; //16
    // / End
    
    /// M: IMS feature. @{
    public static final int IMS_EMERGENCY_REREG = 380;
    /// @}

    ///M: WFC @{
    public static final int WFC_WIFI_SIGNAL_LOST = 400;
    public static final int WFC_ISP_PROBLEM = 401;
    public static final int WFC_HANDOVER_WIFI_FAIL = 402;
    public static final int WFC_HANDOVER_LTE_FAIL = 403;
    ///@}

    /** Smallest valid value for call disconnect codes. */
    public static final int MINIMUM_VALID_VALUE = NOT_DISCONNECTED;

    /** Largest valid value for call disconnect codes. */
    public static final int MAXIMUM_VALID_VALUE = DIAL_MODIFIED_TO_DIAL;

    /** Private constructor to avoid class instantiation. */
    private DisconnectCause() {
        // Do nothing.
    }

    /** Returns descriptive string for the specified disconnect cause. */
    public static String toString(int cause) {
        switch (cause) {
        case NOT_DISCONNECTED:
            return "NOT_DISCONNECTED";
        case INCOMING_MISSED:
            return "INCOMING_MISSED";
        case NORMAL:
            return "NORMAL";
        case LOCAL:
            return "LOCAL";
        case BUSY:
            return "BUSY";
        case CONGESTION:
            return "CONGESTION";
        case INVALID_NUMBER:
            return "INVALID_NUMBER";
        case NUMBER_UNREACHABLE:
            return "NUMBER_UNREACHABLE";
        case SERVER_UNREACHABLE:
            return "SERVER_UNREACHABLE";
        case INVALID_CREDENTIALS:
            return "INVALID_CREDENTIALS";
        case OUT_OF_NETWORK:
            return "OUT_OF_NETWORK";
        case SERVER_ERROR:
            return "SERVER_ERROR";
        case TIMED_OUT:
            return "TIMED_OUT";
        case LOST_SIGNAL:
            return "LOST_SIGNAL";
        case LIMIT_EXCEEDED:
            return "LIMIT_EXCEEDED";
        case INCOMING_REJECTED:
            return "INCOMING_REJECTED";
        case POWER_OFF:
            return "POWER_OFF";
        case OUT_OF_SERVICE:
            return "OUT_OF_SERVICE";
        case ICC_ERROR:
            return "ICC_ERROR";
        case CALL_BARRED:
            return "CALL_BARRED";
        case FDN_BLOCKED:
            return "FDN_BLOCKED";
        case CS_RESTRICTED:
            return "CS_RESTRICTED";
        case CS_RESTRICTED_NORMAL:
            return "CS_RESTRICTED_NORMAL";
        case CS_RESTRICTED_EMERGENCY:
            return "CS_RESTRICTED_EMERGENCY";
        case UNOBTAINABLE_NUMBER:
            return "UNOBTAINABLE_NUMBER";
        case CDMA_LOCKED_UNTIL_POWER_CYCLE:
            return "CDMA_LOCKED_UNTIL_POWER_CYCLE";
        case CDMA_DROP:
            return "CDMA_DROP";
        case CDMA_INTERCEPT:
            return "CDMA_INTERCEPT";
        case CDMA_REORDER:
            return "CDMA_REORDER";
        case CDMA_SO_REJECT:
            return "CDMA_SO_REJECT";
        case CDMA_RETRY_ORDER:
            return "CDMA_RETRY_ORDER";
        case CDMA_ACCESS_FAILURE:
            return "CDMA_ACCESS_FAILURE";
        case CDMA_PREEMPTED:
            return "CDMA_PREEMPTED";
        case CDMA_NOT_EMERGENCY:
            return "CDMA_NOT_EMERGENCY";
        case CDMA_ACCESS_BLOCKED:
            return "CDMA_ACCESS_BLOCKED";
        case EMERGENCY_ONLY:
            return "EMERGENCY_ONLY";
        case NO_PHONE_NUMBER_SUPPLIED:
            return "NO_PHONE_NUMBER_SUPPLIED";
        case DIALED_MMI:
            return "DIALED_MMI";
        case VOICEMAIL_NUMBER_MISSING:
            return "VOICEMAIL_NUMBER_MISSING";
        case CDMA_CALL_LOST:
            return "CDMA_CALL_LOST";
        case EXITED_ECM:
            return "EXITED_ECM";
        case DIAL_MODIFIED_TO_USSD:
            return "DIAL_MODIFIED_TO_USSD";
        case DIAL_MODIFIED_TO_SS:
            return "DIAL_MODIFIED_TO_SS";
        case DIAL_MODIFIED_TO_DIAL:
            return "DIAL_MODIFIED_TO_DIAL";
        case ERROR_UNSPECIFIED:
            return "ERROR_UNSPECIFIED";
        case OUTGOING_FAILURE:
            return "OUTGOING_FAILURE";
        case OUTGOING_CANCELED:
            return "OUTGOING_CANCELED";
        case IMS_MERGED_SUCCESSFULLY:
            return "IMS_MERGED_SUCCESSFULLY";
        /// M: CC008: Call Fail Cause based on CEER @{
        /// [ALPS00093395]
        case NO_ROUTE_TO_DESTINATION:
            return "NO_ROUTE_TO_DESTINATION";
        case NO_USER_RESPONDING:
            return "NO_USER_RESPONDING";
        case USER_ALERTING_NO_ANSWER:
            return "USER_ALERTING_NO_ANSWER";
        case CALL_REJECTED:
            return "CALL_REJECTED";
        case INVALID_NUMBER_FORMAT:
            return "INVALID_NUMBER_FORMAT";
        case FACILITY_REJECTED:
            return "FACILITY_REJECTED";
        case NORMAL_UNSPECIFIED:
            return "NORMAL_UNSPECIFIED";
        case NO_CIRCUIT_AVAIL:
            return "NO_CIRCUIT_AVAIL";
        case SWITCHING_CONGESTION:
            return "SWITCHING_CONGESTION";
        case RESOURCE_UNAVAILABLE:
            return "RESOURCE_UNAVAILABLE";
        case BEARER_NOT_AUTHORIZED:
            return "BEARER_NOT_AUTHORIZED";
        case BEARER_NOT_AVAIL:
            return "BEARER_NOT_AVAIL";
        case SERVICE_NOT_AVAILABLE:
            return "SERVICE_NOT_AVAILABLE";
        case BEARER_NOT_IMPLEMENT:
            return "BEARER_NOT_IMPLEMENT";
        case FACILITY_NOT_IMPLEMENT:
            return "FACILITY_NOT_IMPLEMENT";
        case RESTRICTED_BEARER_AVAILABLE:
            return "RESTRICTED_BEARER_AVAILABLE";
        case OPTION_NOT_AVAILABLE:
            return "OPTION_NOT_AVAILABLE";
        case INCOMPATIBLE_DESTINATION:
            return "INCOMPATIBLE_DESTINATION";
        case CHANNEL_UNACCEPTABLE:
            return "CHANNEL_UNACCEPTABLE";
        case OPERATOR_DETERMINED_BARRING:
            return "OPERATOR_DETERMINED_BARRING";
        case PRE_EMPTION:
            return "PRE_EMPTION";
        case NON_SELECTED_USER_CLEARING:
            return "NON_SELECTED_USER_CLEARING";
        case DESTINATION_OUT_OF_ORDER:
            return "DESTINATION_OUT_OF_ORDER";
        case ACCESS_INFORMATION_DISCARDED:
            return "ACCESS_INFORMATION_DISCARDED";
        case REQUESTED_FACILITY_NOT_SUBSCRIBED:
            return "REQUESTED_FACILITY_NOT_SUBSCRIBED";
        case INCOMING_CALL_BARRED_WITHIN_CUG:
            return "INCOMING_CALL_BARRED_WITHIN_CUG";
        case INVALID_TRANSACTION_ID_VALUE:
            return "INVALID_TRANSACTION_ID_VALUE";
        case USER_NOT_MEMBER_OF_CUG:
            return "USER_NOT_MEMBER_OF_CUG";
        case INVALID_TRANSIT_NETWORK_SELECTION:
            return "INVALID_TRANSIT_NETWORK_SELECTION";
        case SEMANTICALLY_INCORRECT_MESSAGE:
            return "SEMANTICALLY_INCORRECT_MESSAGE";
        case INVALID_MANDATORY_INFORMATION:
            return "INVALID_MANDATORY_INFORMATION";
        case MESSAGE_TYPE_NON_EXISTENT:
            return "MESSAGE_TYPE_NON_EXISTENT";
        case MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROT_STATE:
            return "MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROT_STATE";
        case IE_NON_EXISTENT_OR_NOT_IMPLEMENTED:
            return "IE_NON_EXISTENT_OR_NOT_IMPLEMENTED";
        case CONDITIONAL_IE_ERROR:
            return "CONDITIONAL_IE_ERROR";
        case MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
            return "MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE";
        case RECOVERY_ON_TIMER_EXPIRY:
            return "RECOVERY_ON_TIMER_EXPIRY";
        case PROTOCOL_ERROR_UNSPECIFIED:
            return "PROTOCOL_ERROR_UNSPECIFIED";
        case INTERWORKING_UNSPECIFIED:
            return "INTERWORKING_UNSPECIFIED";
        case CM_MM_RR_CONNECTION_RELEASE:
            return "CM_MM_RR_CONNECTION_RELEASE";
        /// @}
        /// M: CC021: Error message due to CellConnMgr checking @{
        case OUTGOING_CANCELED_BY_SERVICE:
            return "OUTGOING_CANCELED_BY_SERVICE";
        /// @}
        /// M: CC022: Error message due to VoLTE SS checking @{
        case VOLTE_SS_DATA_OFF:
            return "VOLTE_SS_DATA_OFF";
        /// @}
        case CHANNEL_NOT_AVAIL:
	    return "CHANNEL_NOT_AVAIL";

		// / Added by guofeiyao 2015/12/12
		// For Telcel clear code
		case NUMBER_CHANGED:
			return "NUMBER_CHANGED";
		case STATUS_ENQUIRY:
			return "STATUS_ENQUIRY";
		case NETWORK_OUT_OF_ORDER:
			return "NETWORK_OUT_OF_ORDER";
		case QOS_NOT_AVAIL:
			return "QOS_NOT_AVAIL";
        case NORMAL_CLEARING:
            return "NORMAL_CLEARING";
		// / End
		
        default:
            return "INVALID: " + cause;
        }
    }
}
